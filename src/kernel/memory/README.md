# Coronel Memory Management System

This directory contains the complete memory management subsystem for the Coronel kernel, implementing both kernel and user space memory allocation with modern OS design principles. (Document generated by AI)

## Overview

The memory management system is built around a layered architecture that provides:
- **Physical Memory Management**: Frame allocation and tracking
- **Virtual Memory Management**: Address space management and mapping
- **Kernel Heap**: Dynamic kernel memory allocation
- **User Space Allocators**: Per-process isolated memory management
- **Memory Protection**: NULL pointer guards and privilege separation

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    Memory Management Layers                     │
├─────────────────────────────────────────────────────────────────┤
│  System Calls (malloc/free/mmap)                                │
├─────────────────────────────────────────────────────────────────┤
│  User Space Allocator (per-process)                             │
├─────────────────────────────────────────────────────────────────┤
│  Kernel Heap Allocator                                          │
├─────────────────────────────────────────────────────────────────┤
│  Virtual Memory Manager                                         │
├─────────────────────────────────────────────────────────────────┤
│  Physical Frame Allocator                                       │
├─────────────────────────────────────────────────────────────────┤
│  Hardware (Paging, MMU)                                         │
└─────────────────────────────────────────────────────────────────┘
```

## Memory Layout

### Kernel Memory Layout
```
0xffffffff80000000 - 0xffffffffffffffff: Kernel Space (2GB)
├── 0xffffffff80000000: Kernel Code/Data
├── 0xffffffff80326000: Kernel Stack (64KB)
├── 0xffffffffc0000000: PCI/Device Memory
└── Dynamic Kernel Heap (managed by heap.cpp)
```

### User Space Memory Layout (Per Process)
```
0x00000000 - 0x003FFFFF: NULL Guard (4MB) - Unmapped
0x00400000 - 0x07FFFFFF: Code + Data (128MB max)
0x08000000 - 0x3FFFFFFF: Process Heap (768MB max)
0x40000000 - 0x6FFFFFFF: Shared Libraries/mmap (768MB)
0x70000000 - 0x7FFF0000: Reserved
0x7FFF0000 - 0x80000000: User Stack (8MB, grows down)
```

## Components

### Core Files

#### `allocators.cpp/hpp`
**Purpose**: Central allocation interface that bridges all allocators
- Provides `kalloc()` and `kfree()` for kernel code
- Routes requests to appropriate allocator (placement → heap)
- Handles early boot vs runtime allocation decisions

#### `physical.cpp/hpp`
**Purpose**: Physical frame allocator managing RAM pages
- Tracks free 4KB physical frames using linked list
- Handles multiboot memory map parsing
- Provides frame allocation/deallocation for paging
- **Key Functions**: `alloc()`, `free()`, `setup()`

#### `virtual.cpp/hpp` 
**Purpose**: Virtual address space management
- Manages free virtual memory regions
- Implements first-fit allocation strategy  
- Handles region coalescing and splitting
- **Key Functions**: `alloc()`, `free()`, `setup()`

#### `heap.cpp/hpp`
**Purpose**: Dynamic kernel heap allocator
- Advanced block management with splitting/coalescing
- Corruption detection with magic values
- Dynamic heap expansion using virtual/physical managers
- Performance statistics and debugging
- **Key Functions**: `malloc()`, `free()`, `realloc()`

#### `memory_manager.cpp/hpp`
**Purpose**: Initialization coordinator
- Parses multiboot memory information
- Initializes all memory subsystems in correct order
- Provides unified setup interface
- **Key Functions**: `initialize()`

#### `user_allocator.cpp/hpp`
**Purpose**: User space memory allocator
- Per-process heap management with process isolation
- Standard ELF memory layout implementation
- System call interface (malloc/free/mmap/brk)
- Process memory management and cleanup
- **Key Functions**: User space malloc/free, process setup

## Memory Allocation Flow

### Kernel Memory Allocation
```
kalloc() → [Early Boot?] → placement_allocator
           [Runtime]    → kernel_heap → virtual_manager → physical_manager
```

### User Memory Allocation  
```
sys_malloc() → user_allocator → [expand heap?] → kernel (map pages) → physical_manager
```

### Initialization Sequence
```
1. multiboot_info parsing
2. physical_manager.setup() - Initialize frame allocator
3. virtual_manager.setup() - Initialize kernel virtual space  
4. heap.initialize() - Create kernel heap
5. [Per Process] user_allocator() - Create process heaps
```

## Key Design Decisions

### Security
- **NULL Pointer Protection**: 4MB unmapped guard area prevents NULL dereferences
- **Process Isolation**: Each process has separate page directory and heap
- **Privilege Separation**: User/kernel memory strictly separated
- **Stack Guards**: Stack overflow protection through memory layout

### Performance  
- **Block Coalescing**: Reduces fragmentation in both kernel and user heaps
- **First-Fit Strategy**: Fast allocation with good locality
- **Lazy Expansion**: Heaps grow on demand to minimize memory usage
- **Magic Value Corruption Detection**: Fast integrity checks

### Compatibility
- **ELF Standard**: User space follows standard ELF memory layout (0x400000 start)
- **POSIX Compliance**: Standard malloc/free/mmap system call interface
- **Multiboot Support**: Compatible with GRUB and multiboot loaders

## Debugging and Monitoring

### Corruption Detection
Both kernel and user heaps implement corruption detection:
```cpp
// Magic values validate block integrity
constexpr uint64_t HEAP_MAGIC_FREE = 0xDEADBEEFCAFEBABE;
constexpr uint64_t HEAP_MAGIC_USED = 0xFEEDFACEDEADC0DE;
```

### Statistics
The heap allocators track:
- Total allocated memory
- Number of active blocks  
- Allocation/deallocation counts
- Heap expansion events

### Validation
```cpp
bool validate_heap() const;  // Integrity check
void print_statistics();     // Memory usage stats
```

## Usage Examples

### Kernel Memory Allocation
```cpp
// Simple allocation
void* ptr = memory::kalloc(1024);
memory::kfree(ptr);

// Aligned allocation  
paddr_t phys_addr;
void* aligned_ptr = placement_kalloc(4096, &phys_addr, true);
```

### User Space Setup
```cpp
// Create process memory
paddr_t page_dir = paging.create_user_page_directory();
process_memory* proc_mem = new process_memory(page_dir);

// Setup memory layout
proc_mem->setup_memory_layout(code_addr, code_size, data_addr, data_size);
proc_mem->setup_stack(USER_STACK_SIZE);

// User can now call malloc/free through system calls
```

### System Call Interface
```cpp
// User space calls (would be implemented in libc)
void* ptr = malloc(1024);    // → sys_malloc()
free(ptr);                   // → sys_free()
void* map = mmap(...);       // → sys_mmap()
```

## Error Handling

### Common Error Conditions
- **Out of Memory**: Physical frames exhausted
- **Virtual Space Exhausted**: No free virtual regions
- **Corruption Detected**: Magic value mismatch
- **Double Free**: Freeing already freed memory
- **Invalid Pointer**: Freeing non-heap pointer

### Recovery Strategies
- **Graceful Degradation**: Return NULL on allocation failure
- **Logging**: Comprehensive error logging for debugging
- **Cleanup**: Automatic cleanup on process termination
- **Validation**: Extensive pointer and heap validation

## Testing and Validation

### Built-in Tests
```cpp
// Heap integrity validation
bool heap_ok = heap.validate_heap();

// Memory leak detection
size_t leaked = heap.get_total_allocated();

// Corruption detection
// Automatic on every allocation/deallocation
```

### Stress Testing
The allocators are designed to handle:
- Rapid allocation/deallocation cycles
- Large allocations (up to heap limits)
- Fragmentation scenarios
- Concurrent access (with proper locking)

## Future Enhancements

### Planned Features
- **NUMA Support**: Non-uniform memory architecture optimization
- **Memory Compression**: Swap compression for better performance
- **Guard Pages**: Additional overflow protection
- **Memory Pools**: Specialized allocators for common sizes
- **Performance Profiling**: Advanced allocation tracking

### Scalability
- **Per-CPU Heaps**: Reduce lock contention
- **Lock-Free Algorithms**: Improve concurrent performance
- **Huge Pages**: Support for 2MB/1GB pages
- **Memory Hotplug**: Dynamic memory addition/removal

## Contributing

When modifying the memory management system:

1. **Run validation**: Always call `validate_heap()` after changes
2. **Check statistics**: Monitor memory usage for leaks
3. **Test edge cases**: NULL pointers, zero sizes, huge allocations
4. **Document changes**: Update this README for architectural changes
5. **Maintain compatibility**: Preserve existing interfaces

## References

- Intel 64 and IA-32 Architectures Software Developer's Manual
- ELF Specification (System V ABI)
- Linux Kernel Memory Management Documentation
- Modern Operating Systems by Andrew Tanenbaum
- Understanding the Linux Kernel by Daniel Bovet

---